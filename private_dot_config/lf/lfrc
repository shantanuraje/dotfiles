# lf Configuration - Optimized for Performance and Usability
# Fast file manager with Miller columns and vi-like keybindings

# === Basic Settings ===
set preview true
set hidden false
set drawbox true
set icons true
set ignorecase true
set incsearch true
set scrolloff 10
set tabstop 4
set smartcase true
set wrapscan true
set number true
set relativenumber true

# Performance optimizations
set period 1
set findlen 1
set promptfmt "\033[32;1m%u@%h\033[0m:\033[34;1m%w/\033[0m\033[1m%f\033[0m"

# === Preview Settings ===
set previewer ~/.config/lf/preview.sh
set cleaner ~/.config/lf/cleaner.sh

# === Custom Commands ===

# Archive extraction
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf "$f";;
        *.tar.gz|*.tgz) tar xzvf "$f";;
        *.tar.xz|*.txz) tar xJvf "$f";;
        *.zip) unzip "$f";;
        *.rar) unrar x "$f";;
        *.7z) 7z x "$f";;
        *) echo "Unsupported format";;
    esac
}}

# Archive creation
cmd zip %zip -r "$f" "$f"
cmd tar %tar czf "$f.tar.gz" "$f"

# Open with CLI tools first, fallback to GUI programs
cmd open ${{
    case $(file --mime-type -Lb $f) in
        text/*|application/json|application/xml) $EDITOR "$f";;
        image/*) 
            # CLI image viewers first, fallback to GUI
            if command -v chafa >/dev/null 2>&1; then
                chafa "$f" | less -R
            elif command -v viu >/dev/null 2>&1; then
                viu "$f"
            elif command -v feh >/dev/null 2>&1; then
                feh "$f" >/dev/null 2>&1 &
            elif command -v eog >/dev/null 2>&1; then
                eog "$f" >/dev/null 2>&1 &
            else
                xdg-open "$f" >/dev/null 2>&1 &
            fi;;
        video/*|audio/*)
            # mpv first (works in terminal), fallback to vlc
            if command -v mpv >/dev/null 2>&1; then
                mpv "$f"
            elif command -v vlc >/dev/null 2>&1; then
                vlc "$f" >/dev/null 2>&1 &
            else
                xdg-open "$f" >/dev/null 2>&1 &
            fi;;
        application/pdf)
            # CLI PDF viewers first, fallback to GUI
            if command -v termpdf >/dev/null 2>&1; then
                termpdf "$f"
            elif command -v zathura >/dev/null 2>&1; then
                zathura "$f" >/dev/null 2>&1 &
            elif command -v mupdf >/dev/null 2>&1; then
                mupdf "$f" >/dev/null 2>&1 &
            elif command -v evince >/dev/null 2>&1; then
                evince "$f" >/dev/null 2>&1 &
            else
                pdftotext "$f" - | less 2>/dev/null || xdg-open "$f" >/dev/null 2>&1 &
            fi;;
        application/zip|application/x-tar|application/x-7z-compressed|application/x-rar)
            # CLI archive listing first, fallback to GUI archive manager
            case "$f" in
                *.zip) 
                    if command -v unzip >/dev/null 2>&1; then
                        unzip -l "$f" | less
                    else
                        xdg-open "$f" >/dev/null 2>&1 &
                    fi;;
                *.tar.gz|*.tgz) tar -tzf "$f" | less;;
                *.tar.bz2|*.tbz2) tar -tjf "$f" | less;;
                *.tar.xz|*.txz) tar -tJf "$f" | less;;
                *.tar) tar -tf "$f" | less;;
                *.7z) 
                    if command -v 7z >/dev/null 2>&1; then
                        7z l "$f" | less
                    else
                        xdg-open "$f" >/dev/null 2>&1 &
                    fi;;
                *.rar) 
                    if command -v unrar >/dev/null 2>&1; then
                        unrar l "$f" | less
                    else
                        xdg-open "$f" >/dev/null 2>&1 &
                    fi;;
                *) xdg-open "$f" >/dev/null 2>&1 &;;
            esac;;
        *) xdg-open "$f" >/dev/null 2>&1 &;;
    esac
}}

# Edit with nvim
cmd edit $$EDITOR "$f"

# Create new file/directory
cmd mkdir %mkdir -p "$@"
cmd mkfile %touch "$@"

# Bulk rename
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS="$(printf '\t')" read -r src dst
    do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id reload"
}}

# Direct fzf file finder (like nff bash function)
cmd fzf_files ${{
    if command -v fd >/dev/null 2>&1; then
        cmd="fd --type f --hidden --follow --exclude .git"
    else
        cmd="find . -type f -not -path '*/.*'"
    fi
    
    if command -v bat >/dev/null 2>&1; then
        preview="bat --color=always --style=numbers --line-range=:500 {}"
    else
        preview="head -50 {}"
    fi
    
    res="$($cmd | fzf --height=50% --layout=reverse --border \
        --preview="$preview" --preview-window=right:50%:wrap \
        --header='Select file to navigate to')"
    
    if [ -n "$res" ] && [ -f "$res" ]; then
        lf -remote "send $id select \"$res\""
    fi
}}

# Direct fzf directory finder (like nf bash function)
cmd fzf_dirs ${{
    if command -v fd >/dev/null 2>&1; then
        cmd="fd --type d --hidden --follow --exclude .git"
    else
        cmd="find . -type d -not -path '*/.*'"
    fi
    
    res="$($cmd | fzf --height=50% --layout=reverse --border \
        --preview='ls -la {} | head -20' --preview-window=right:50%:wrap \
        --header='Select directory to navigate to')"
    
    if [ -n "$res" ] && [ -d "$res" ]; then
        lf -remote "send $id cd \"$res\""
    fi
}}

# Content search with ripgrep (like nrg bash function)
cmd fzf_rg ${{
    if ! command -v rg >/dev/null 2>&1; then
        echo "ripgrep not found"
        return
    fi
    
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
        fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --disabled \
            --height=50% --layout=reverse --border \
            --delimiter ':' \
            --preview 'bat --color=always --highlight-line {2} {1}' \
            --preview-window '+{2}/2' \
            --header='Search file contents')"
    
    if [ -n "$res" ]; then
        filename="$(echo "$res" | cut -d':' -f1)"
        if [ -f "$filename" ]; then
            lf -remote "send $id select \"$filename\""
        fi
    fi
}}

# Git operations
cmd git_branch ${{
    git branch | fzf | xargs git checkout
    pwd_shell=$(pwd)
    lf -remote "send $id updir"
    lf -remote "send $id cd \"$pwd_shell\""
}}

cmd git_log ${{
    git log --oneline --color=always | fzf --ansi +s | awk '{print $1}' | xargs git show
}}

# Trash functionality (safer than rm)
cmd trash %{{
    files=$(printf "$fx" | tr '\n' ';')
    while [ "$files" ]; do
        file=${files%%;*}
        trash-put "$(basename "$file")"
        if [ "$files" = "$file" ]; then
            files=''
        else
            files="${files#*;}"
        fi
    done
}}

# Advanced selection
cmd select-files ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
        if [ "$lf_hidden" = "false" ]; then
          grep -v '/\.[^/]*$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -I{} lf -remote "send $id toggle {}"
}}

cmd select-dirs ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type d; } |
        if [ "$lf_hidden" = "false" ]; then
          grep -v '/\.[^/]*$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -I{} lf -remote "send $id toggle {}"
}}

# === Key Bindings ===

# Navigation
map h updir
map l open
map j down
map k up
map gg top
map G bottom

# File operations
map a mkfile
map A mkdir
map d trash
map D delete
map r rename
map R bulk-rename
map c copy
map x cut
map v paste
map u unselect

# Archive operations
map ex extract
map zz zip
map zt tar

# Application shortcuts
map e edit
map E $$EDITOR "$f"
map o open
map O $mimeopen --ask "$f"

# Search and navigation  
map f fzf_files
map d fzf_dirs
map r fzf_rg
map / search
map n search-next
map N search-prev

# Selection
map sf select-files
map sd select-dirs
map sa invert
map <space> toggle

# Git integration
map gb git_branch
map gl git_log

# Quick directories (bookmarks)
map gh cd ~
map gd cd ~/Downloads
map gp cd ~/Projects
map gc cd ~/.config
map gs cd ~/.local/share/chezmoi
map gn cd ~/system_nixos
map gw cd /etc/nixos

# Toggle settings
map zh set hidden!
map zp set preview!
map zi set icons!
map zr set reverse!

# Shell
map w $$SHELL

# Reload
map <c-r> reload

# === Icon Configuration ===
# File type icons for better visual identification
set icons true

# === Integration with External Tools ===

# Use bat for text preview
map <enter> ${{
    case $(file --mime-type -Lb $f) in
        text/*|application/json) bat --color=always --style=numbers --paging=never "$f" | head -50;;
        *) file "$f";;
    esac
}}

# Quick edit with nvim
map ee $$EDITOR "$f"

# View with less
map vv $less "$f"

# Quick image view
map ii $feh "$f" 2>/dev/null &

# === Terminal Integration ===
# Better integration with kitty/alacritty
map <c-z> $ kill -STOP $PPID